= OpenSCAD
:toc:
:imagesdir: ../images/openscad/
:experimental:
// experimental for the kbd macro

Program http://www.openscad.org/[OpenSCAD] slouÅ¾Ã­ k modelovÃ¡nÃ­ 3D modelÅ¯ nejen
pro 3D tiskÃ¡rny. Je to program umoÅ¾ÅˆujÃ­cÃ­ CSG modelovÃ¡nÃ­ deklarativnÃ­m
zÃ¡pisem -- kÃ³dem.

.Program OpenSCAD
image::openscad.png[width=555]

VyÄerpÃ¡vajÃ­cÃ­ http://en.wikibooks.org/wiki/OpenSCAD_User_Manual[manuÃ¡l
v angliÄtinÄ›] pouÅ¾ijte jako referenci.


== CSG modelovÃ¡nÃ­

http://cs.wikipedia.org/wiki/Constructive_solid_geometry[CSG modelovÃ¡nÃ­]
(_Constructive Solid Geometry_) je vektorovÃ© modelovÃ¡nÃ­ grafickÃ½ch prvkÅ¯,
v naÅ¡em pÅ™Ã­padÄ› 3D modelÅ¯.
ZÃ¡kladnÃ­ *primitiva* (koule, kuÅ¾el/vÃ¡lec, kvÃ¡drâ€¦) se sklÃ¡dajÃ­ do *CSG stromu*
pomocÃ­ hran *transformacÃ­* (posun, Å¡kÃ¡lovÃ¡nÃ­, rotaceâ€¦)
a uzlÅ¯ *booleovskÃ½ch operacÃ­* (rozdÃ­l, prÅ¯nik, slouÄenÃ­).

Na obrÃ¡zku vidÃ­te ilustraci CSG stromu. Zde jsou pro zjednoduÅ¡enÃ­ primitivy
jiÅ¾ otoÄenÃ©.

.CSG strom. Â© http://commons.wikimedia.org/wiki/File:Csg_tree.png[Zottie], GNU FDL
image::csg_tree.png[width=555]

OpenSCAD umoÅ¾Åˆuje takovÃ© stromy zapsat pomocÃ­ kÃ³du a vyrendorvat z nich vÃ½slednÃ½
3D model ve formÄ› xref:mesh#[triangulÃ¡rnÃ­ meshe] (o tÃ© se budeme uÄit pozdÄ›ji).

== UÅ¾ivatelskÃ© rozhranÃ­

Okno programu se sklÃ¡dÃ¡ ze tÅ™Ã­ ÄÃ¡stÃ­:

Editor::
  (vlevo) V nÄ›m pÃ­Å¡ete zdrojovÃ½ kÃ³d modelu.

NÃ¡hled::
  (vpravo) 3D plÃ¡tno, kde uvidÃ­te nÃ¡hled modelu.

Konzole::
  (vpravo dole) V konzoli je vidÄ›t chybovÃ½ a ladÃ­cÃ­ vÃ½stup.

Po napsÃ¡nÃ­ kÃ³du do editoru je tÅ™eba model â€zkompilovatâ€œ.
Existuje rychlÃ½ (ne vÅ¾dy pÅ™esnÃ½) nÃ¡hled pomocÃ­ OpenGL (_Design â†’ Zobrazit_, kbd:[F5])
a plnohodnotnÃ½ render do 3D modelu pro export (poÄÃ­tÃ¡ se bohuÅ¾el na procesoru,
_Design â†’ Vyrenderovat_, kbd:[F6]).
V nabÃ­dce _Design_ lze zapnout i _Automaticky naÄÃ­tat a zobrazovat_, po uloÅ¾enÃ­
se pak provede nÃ¡hled automaticky.

V nabÃ­dce _Zobrazit_ najdete spousto moÅ¾nostÃ­ pro zobrazenÃ­ nÃ¡hledu,
doporuÄujeme zapnout _osy_ a _pravÃ­tko_.

Pro pohyb modelem pozdÄ›ji pouÅ¾ijete myÅ¡ (vyzkouÅ¡ejte rÅ¯znÃ¡ tlaÄÃ­tka).

Abyste nÄ›co vidÄ›li, potÅ™ebujete ale zdrojovÃ½ kÃ³d.
MÅ¯Å¾ete si vybrat z pestrÃ© nabÃ­dky _Soubor â†’ PÅ™Ã­klady_.

== Syntax

Syntaxe je hned na prvnÃ­ pohled velmi *podobnÃ¡ C/C++/JavÄ›* --
obsahuje stÅ™ednÃ­ky, chlupatÃ© zÃ¡vorky, komentÃ¡Å™e se pÃ­Å¡Ã­ stejnÄ›.
KromÄ› jinÃ©ho mÅ¯Å¾ete psÃ¡t *ÄÃ­sla*
(buÄ celÃ¡, nebo s plovoucÃ­ desetinnou ÄÃ¡rkou (zÃ¡pis pomocÃ­ teÄky nebo vÄ›decky)) --
`1`, `0`, `-5`, `5.3`, `9.99998`, `185e-5`;
*vektory/souÅ™adnice* v hranatÃ½ch zÃ¡vorkÃ¡ch --
`[1, 2, 3]`; *Å™etÄ›zce* ve `"dvojitÃ½ch uvozovkÃ¡ch"`, **boolean** `true`/`false`.

MÅ¯Å¾ete pouÅ¾Ã­vat *promÄ›nnÃ©* (kterÃ© se nedeklarujÃ­, ale chovajÃ­ se nestandardnÄ›,
k tomu se dostaneme dÃ¡le), *matematickÃ©
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators[vÃ½razy]*
a
*http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Functions[funkce]*,
konstantu `PI`â€¦

WARNING: Nenechte se syntaxÃ­ zmÃ¡st, nejednÃ¡ se o programovacÃ­, ale deskriptivnÃ­ jazyk!
To znamenÃ¡, Å¾e jednotlivÃ© pÅ™Ã­kazy a vÃ½razy se nedÄ›jÃ­ postupnÄ› odshora dolÅ¯,
ale spolu najednou popisujÃ­ vÃ½sledek -- CSG strom.

TIP: http://www.openscad.org/cheatsheet/[PÅ™ehlednÃ½ tahÃ¡k.]

== Primitiva

`cube(size, center);`::
  kvÃ¡dr (`size=[1, 2, 3]`) nebo krychle (`size=5`)

`sphere(r);`::
  koule (lze pouÅ¾Ã­t `r` -- polomÄ›r nebo `d` -- prÅ¯mÄ›r)

`cylinder(...);`::
  (komolÃ½) kuÅ¾el (`h, r1, r2, center`) nebo vÃ¡lec (`h, r, center`)

`polyhedron(...);`::
  mnohostÄ›n, nÃ­zkoÃºrovÅˆovÃ¡ primitiva popisujÃ­cÃ­ pÅ™Ã­mo triangulÃ¡rnÃ­ mesh

NOTE: VÅ¡echny ÄÃ­slice urÄujÃ­cÃ­ rozmÄ›r jsou bez jednotky, protoÅ¾e vÃ½slednÃ½
3D model takÃ© Å¾Ã¡dnÃ© nemÃ¡. To umoÅ¾Åˆuje modelovat vesmÃ­rnÃ¡ tÄ›lesa Äi subatomÃ¡rnÃ­
ÄÃ¡stice bez nutnosti pouÅ¾Ã­vat velmi velkÃ©/malÃ© hodnoty.
Pro ÃºÄely 3D tisku si za ÄÃ­slicemi pÅ™edstavujte milimetry.

.UkÃ¡zka pouÅ¾itÃ­ dvou primitiv. V tomto pÅ™Ã­padÄ› se provede _implicitnÃ­ slouÄenÃ­_
[source,scad]
----
cube(150, center=true); // <1>
sphere(100); // <2>
----
<1> vycentrovanÃ¡ krychle o hranÄ› dÃ©lky 150 (vÅ¡imnÄ›te si, Å¾e argumenty se dajÃ­ pÅ™edÃ¡vat poziÄnÄ› i pomocÃ­ jmÃ©na)
<2> koule o polomÄ›ru 100

.UkÃ¡zka pouÅ¾itÃ­ dvou primitiv
image::ex1.png[]

== Transformace

KdyÅ¾ uÅ¾ umÃ­te vytvÃ¡Å™et primitivnÃ­ geometrickÃ¡ tÄ›lesa, je dobrÃ© nauÄit se s nimi
provÃ¡dÄ›t jednotlivÃ© transformace.

`scale()`::
  Å¡kÃ¡luje objekt o zadanou konstantu nebo vektor tÅ™Ã­ hodnot

`resize()`::
  Å¡kÃ¡luje objekt *na* zadanou velikost

`rotate()`::
  objekt otÃ¡ÄÃ­ o Ãºhel zadanÃ½ ve stupnÃ­ch, pouÅ¾ije se jako
  `rotate([deg,deg,deg])` nebo `rotate(deg,[1,1,0])`

`translate([x, y, z])`::
  relativnÃ­ posun objektu

`mirror([x, y, z])`::
  pÅ™eklopÃ­ (zrcadlÃ­) objekt podle poÄÃ¡tkem prochÃ¡zejÃ­cÃ­ roviny se zadanÃ½m normÃ¡lovÃ½m vektorem,
  napÅ™. `[1, 0, 0]` zrcadlÃ­ podle roviny _YZ_; zrcadlenÃ½ objekt se neduplikuje

`multmatrix([[...]])`::
  transformaÄnÃ­ matice velikosti 4Ã—4, nÃ­zkoÃºrovÅˆovÃ©

`color(...)`::
  obarvÃ­ objekt zadanou barvou, funguje jen v nÃ¡hledu

Transformace se aplikujÃ­ zÃ¡pisem pÅ™ed objekt, kterÃ½ chcete transformovat:
`transformace() objekt();`. DajÃ­ se takÃ© Å™etÄ›zit, jsou aplikovanÃ© postupnÄ› od
â€nejbliÅ¾Å¡Ã­â€œ po nejvzdÃ¡lenÄ›jÅ¡Ã­. DajÃ­ se aplikovat i na vÃ­ce objektÅ¯ souÄasnÄ›,
zabalenÃ­m objektÅ¯ do chlupatÃ½ch zÃ¡vorek a pÅ™edsazenÃ­m pÅ™ed nÄ›.

.Transformace aplikovanÃ¡ na vÃ­ce objektÅ¯ souÄasnÄ›
[source,scad]
----
transformce() {
  objekt1();
  objekt2();
}
----

IMPORTANT: VeÅ¡kerÃ© operace (snad kromÄ› barvy) se dÄ›jÃ­ *kolem poÄÃ¡tku souÅ™adnic*.
NapÅ™. pokud objekt leÅ¾Ã­ nÄ›kde mimo poÄÃ¡tek a vy jej otoÄÃ­te, jeho poloha se zmÄ›nÃ­.

.Na poÅ™adÃ­ operacÃ­ zÃ¡leÅ¾Ã­
[source,scad]
----
color("green") rotate([0,0,60]) translate([30,0,0]) cube(5); // <1>
color("red") translate([30,0,0]) rotate([0,0,60]) cube(5); // <2>
----
<1> Kostka se nejprve posune, potÃ© otoÄÃ­ kolem poÄÃ¡tku a nakonec obarvÃ­
<2> Kostka se nejprve otoÄÃ­ kolem poÄÃ¡tku, potÃ© posune a nakonec obarvÃ­

.Na poÅ™adÃ­ operacÃ­ zÃ¡leÅ¾Ã­
image::ex2.png[]

== BooleovskÃ© operace

ZÃ¡kladem CSG modelovÃ¡nÃ­ jsou tÅ™i boolovskÃ© operace:

`union()` -- slouÄenÃ­::
  z vÃ­ce objektÅ¯ udÄ›lÃ¡ jeden
  (pokud by mÄ›l mÃ­t vÃ½slednÃ½ CSG strom vÃ­ce koÅ™enÅ¯, provede se na nich implicitnÄ›)

`difference()` -- rozdÃ­l::
  od prvnÃ­ho objektu odeÄte vÅ¡echny dalÅ¡Ã­

`intersection()` -- prÅ¯nik::
  zÅ¯stane pouze spoleÄnÃ¡ ÄÃ¡st vÅ¡ech objektÅ¯

.SlouÄenÃ­ (to by se zde provedlo implicitnÄ›, ale jinde pÅ™ijde vhod)
[source,scad]
----
union() {
  cube(150, center=true);
  sphere(100);
}
----

.SlouÄenÃ­
image::ex1.png[]

.RozdÃ­l
[source,scad]
----
difference() {
  cube(150, center=true);
  sphere(100);
}
----

.RozdÃ­l
image::ex3.png[]

.PrÅ¯nik
[source,scad]
----
intersection() {
  cube(150, center=true);
  sphere(100);
}
----

.PrÅ¯nik
image::ex4.png[]

VÅ¡echny tyto operace nemajÃ­ Å¾Ã¡dnÃ© argumenty, ale zpracujÃ­ libovolnÃ½ poÄet objektÅ¯.
TakovÃ½m objektÅ¯m se Å™Ã­kÃ¡ *children* danÃ© operace.
ÄŒesky to znamenÃ¡ _dÄ›ti_, ale my tento pojem radÄ›ji pÅ™eklÃ¡dat nebudeme.

== PouÅ¾itÃ­ promÄ›nnÃ½ch

NenÃ­ nutnÃ© vÅ¡ude pouÅ¾Ã­vat hodnoty pÅ™Ã­mo, v OpenSCADu se dajÃ­ pouÅ¾Ã­vat i promÄ›nnÃ©.

.PouÅ¾itÃ­ promÄ›nnÃ©
[source,scad]
----
awesome = 42;
cylinder(h=awesome, r=awesome/2);
----

MÄ›jte ale na pamÄ›ti fakt, Å¾e *vÅ¡echno se dÄ›je zÃ¡roveÅˆ*.
PromÄ›nou proto nelze pÅ™edefinovat, respektive lze, ale chovÃ¡ se to jinak,
neÅ¾ jste zvyklÃ­.

.PromÄ›nnou lze pÅ™edefinovat, ale neuvÄ›Å™Ã­te, co se stane
[source,scad]
----
awesome = 42;
echo(awesome); // <1>
awesome = 4242; // <2>
echo(awesome);
----
<1> funkce echo vypisuje ladÃ­cÃ­ informace do konzole
<2> pÅ™enastavenÃ­, co se stane?

VÃ½sledkem je dvakrÃ¡t vypsanÃ© `ECHO: 4242` ğŸ¤¯
DÅ¯vodem je to, Å¾e nezÃ¡leÅ¾Ã­, kdy promÄ›nnou nastavÃ­te, jejÃ­ hodnota platÃ­ v celÃ©m
scopu. Pokud promÄ›nnou nastavÃ­te v jednom scopu dvakrÃ¡t, platÃ­ pozdÄ›ji uvedenÃ¡
hodnota, to berte ale jen jako implementaÄnÃ­ detail a *nikdy to nedÄ›lejte*.

WARNING: Ze stejnÃ©ho dÅ¯vodu nemÅ¯Å¾ete pouÅ¾Ã­t `a = a + 1;` a syntaxe pro
`a += 1;` ani neexistuje (jednÃ¡ se o syntaktickou chybu).

PomÅ¯Å¾e *o promÄ›nnÃ½ch uvaÅ¾ovat jako o konstantÃ¡ch* pro danÃ½ scope.
ZatÃ­m znÃ¡me jen jeden (globÃ¡lnÃ­) scope, ale to se brzy zmÄ›nÃ­.

== Cykly

[quote, Forrestova mÃ¡ma]
Two or more, use a for.

Syntaxe foru je kapku odliÅ¡nÃ¡ od C a vypadÃ¡ asi takto:

.Syntax cyklu for
[source,scad]
----
for (var = [...]) { // <1>
    ... // <2>
}
----
<1> hlaviÄka cyklu, do promÄ›nnÃ© pÅ™iÅ™adÃ­me vektor
<2> v tÄ›le cyklu promÄ›nnÃ¡ `var` nabÃ½vÃ¡ hodnot z pouÅ¾itÃ©ho vektoru

Zastavme se na chvÃ­li u zÃ¡pisu vektorÅ¯, kterÃ© jde zapsat nÄ›kolika zpÅ¯soby:

vÃ½Ätem::
  `var = [-1, 1]` -- hodnoty -1 a 1

intervalem::
  `var = [0 : 5]` -- celÃ¡ ÄÃ­sla od 0 do 5, obÄ› meze jsou pouÅ¾ity

intervalem se skokem::
  `var = [0 : 0.2 : 5]` -- hodnoty od 0 do 5 (vÄetnÄ›), pouÅ¾ije se krok 0,2

Toho Äasto vyuÅ¾ijeme v zÃ¡pisu cyklu for.

.Cyklus s intervalem
[source,scad]
----
for (i = [0:10:100]) echo(i); // => ECHO 10, 20, 30...
----

NOTE: PozornÃ½ ÄtenÃ¡Å™ si teÄ Å™ekne, jak je moÅ¾nÃ©, Å¾e nÃ¡m tady nÄ›co cyklÃ­ a
postupnÄ› nÄ›co dÄ›lÃ¡, kdyÅ¾ se vÅ¡echno dÄ›je najednou.
For zde vytvoÅ™Ã­ nÄ›kolik odnoÅ¾Ã­ CSG stromu, kaÅ¾dou s vlastnÃ­m scopem,
aby mohla bÃ½t hodnota promÄ›nnÃ© jinÃ¡, a *na vÃ½sledku provede sjednocenÃ­*.
JednotlivÃ© hodnoty z ladÃ­cÃ­ho vÃ½pisu vidÃ­te postupnÄ›, protoÅ¾e jinak to nejde.

.intersection_for je speciÃ¡lnÃ­ varianta foru, kterÃ¡ neprovÃ¡dÃ­ sjednocenÃ­, ale prÅ¯nik
[source,scad]
----
intersection_for(n = [1 : 6]) {
  rotate([0,0,n*60]) translate([5,0,0]) sphere(12);
}
----

.intersection_for
image::ex6.png[]

Cykly lze samozÅ™ejmÄ› do sebe vnoÅ™ovat, existuje k tomu i zkratka.

.VnoÅ™enÃ© cykly
[source,scad]
----
for (xpos=[0:3]) {
  for (ypos=[2,4,6]) { // <1>
    ...
  }
}

for (xpos=[0:3], ypos=[2,4,6]) { // <2>
  ...
}
----
{nbsp}
// we put in {nbsp} for
// https://gitlab.fit.cvut.cz/course-pages/course-pages/issues/102

<1> VnoÅ™enÃ½ cyklus
<2> Zkratka (_syntactic sugar_) pro vnoÅ™enÃ½ cyklus

Vzhledem k tomu, jak cyklus for v OpenSCADu funguje, zde vypichujeme nÄ›kolik
informacÃ­, na kterÃ© pozornÃ½ ÄtenÃ¡Å™ jistÄ› jiÅ¾ pÅ™iÅ¡el sÃ¡m:

* KaÅ¾dÃ¡ â€iteraceâ€œ cyklu mÃ¡ vlastnÃ­ cope, jakÃ©koliv nastavenÃ­ promÄ›nnÃ½ch
  v dalÅ¡Ã­ iteraci (a takÃ© po skonÄenÃ­ cyklu) pozbÃ½vÃ¡ platnosti.
* Z pÅ™edchozÃ­ho bodu plyne, Å¾e v cyklu se nedÃ¡ nic iterativnÄ› poÄÃ­tat,
  je moÅ¾nÃ© pouze pouÅ¾Ã­t matematickÃ© vÃ½razy s Å™Ã­dÃ­cÃ­ promÄ›nnou.
* Cyklus while nedÃ¡vÃ¡ v OpenSCADu smysl a tedy neexistuje.

== PodmÃ­nky

OpenSCAD obsahuje dva druhy podmÃ­nek: *if* a *ternÃ¡rnÃ­ operÃ¡tor*.

=== if, else if, else

Syntaxe podmÃ­nky if nenÃ­ pÅ™ekvapujÃ­cÃ­ (chlupatÃ© zÃ¡vorky jsou volitelnÃ©):

.Syntax podmÃ­nky if
[source,scad]
----
if (...) { // <1>
  ... // <2>
} else if (...) { // <3>
  ... // <4>
} else { // <5>
  ... // <6>
}
----
<1> pravdivostnÃ­ vÃ½raz (napÅ™. `a > b`, `0`, `true`, `len(vec) != 42`)
<2> vlastnÃ­ scope!
<3> volitelnÃ¡ vÄ›tev s jinou podmÃ­nkou
<4> vlastnÃ­ scope!
<5> volitelnÃ¡ vÄ›tev, kdyÅ¾ Å¾Ã¡dnÃ¡ podmÃ­nka neplatÃ­
<6> vlastnÃ­ scope!

JednotlivÃ© vÄ›tve podmÃ­nky *majÃ­ vlastnÃ­ scope*.
To znamenÃ¡, Å¾e nenÃ­ nÃ¡sledujÃ­cÃ­ kÃ³d mÅ¯Å¾e mÃ­t pro nÄ›koho pÅ™ekvapujÃ­cÃ­ vÃ½sledek:

.Na tohle se studenti vÅ¾dy nachytajÃ­, ptali bychom se na to u zkouÅ¡ky, kdybychom nÄ›jakou mÄ›li
[source,scad]
----
num = 42;

if (num > 0) {
  sign = 1;
} else if (num < 0) {
  sign = -1;
} else {
  sign = 0;
}

echo(sign); // WARNING: Ignoring unknown variable 'sign'.
----

Tuto vlastnost OpenSCADu lze obejÃ­t jedinÄ› ternÃ¡rnÃ­m operÃ¡torem.

=== TernÃ¡rnÃ­ operÃ¡tor

TernÃ¡rnÃ­ operÃ¡tor, je jedinÃ½ zpÅ¯sob,
jak nastavit nÄ›jakou hodnotu s dlouhodobou platnostÃ­.

.TernÃ¡rnÃ­ operÃ¡tor
[source,scad]
----
num = 42;

// var =   test ? TrueValue : FalseValue;

sign = num > 0 ? 1 : (num < 0 ? -1 : 0); // <1>
echo(sign); // ECHO: 1
----
<1> Zde noÅ™Ã­me operÃ¡tory do sebe

== Funkce

PodobnÄ› jako ternÃ¡rnÃ­ operÃ¡tor se zapisujÃ­ funkce. Funkce nevytvÃ¡Å™Ã­ ÄÃ¡sti CSG
stromu, pouze poÄÃ­tajÃ­ nÄ›jakou hodnotu ze svÃ©ho vstupu.
Jsou to jednovÃ½razovÃ© zkratky.

[source,scad]
function name ( parameters ) = expression;

Funkcemi se v tomto kurzu moc nezabÃ½vÃ¡me,
ale zvÃ­davÃ­ studenti je mohou samozÅ™ejmÄ› pouÅ¾Ã­vat.
https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#Functions[VÃ­ce o funkcÃ­ch v manuÃ¡lu].

== Moduly

Ekvivalentem k funkci pro CSG strom je *modul*.
Modul se vÃ­ce podobÃ¡ funkcÃ­m, jak je znÃ¡me z programovacÃ­ch jazykÅ¯,
s tÃ­m rozdÃ­lem, Å¾e nevracÃ­ Å¾Ã¡dnou hodnotu, ale uzel (Äi hranu) CSG stromu.

Laicky Å™eÄeno: model nÄ›co â€nakreslÃ­â€œ tam, kde se pouÅ¾ije.

StejnÄ› jako funkce, pÅ™ijÃ­mÃ¡ model parametry,
kterÃ© mohou nabÃ½vat vÃ½chozÃ­ch hodnot.
NavÃ­c mÅ¯Å¾e pÅ™ijÃ­mat (zpracovÃ¡vat) `children()`.

Moduly (a funkce) mohou existovat v samostatnÃ½ch souborech (knihovnÃ¡ch),
ve vlastnÃ­m souboru s modelem mÅ¯Å¾ete pouÅ¾Ã­t `use` nebo
`include`:

`use <lib.scad>;`::
  dÃ¡ k dispozici moduly a funkce ze souboru `lib.scad`

`include <lib.scad>;`::
  na mÃ­sto vloÅ¾Ã­ celÃ½ soubor `lib.scad` (pÅ™Ã­padnÃ© objekty se rovnou vykreslÃ­)

.PÅ™Ã­klad vlastnÃ­ho modulu (vÃ¡lec s kulatÃ½mi konci)
[source,scad]
----
module rounded_cylinder(h=20, r=5, center=false) {
  baseh = h-2*r;
  translate([0, 0, center ? -baseh/2 : r]) {
    cylinder(h=baseh, r=r);
    sphere(r);
    translate([0, 0, baseh]) sphere(r);
  }
}

// pro zobrazenÃ­ musÃ­te modul zavolat
rounded_cylinder(center=true);
----

.VÃ¡lec s kulatÃ½mi konci
image::ex7.png[]

=== children()

KromÄ› modulÅ¯, kterÃ© vytvÃ¡Å™ejÃ­ tvary jen na zÃ¡kladÄ› vstupnÃ­ch parametrÅ¯
(argumentÅ¯), jdou vytvÃ¡Å™et i moduly, kterÃ© pÅ™ijÃ­majÃ­ `children()`.

PouÅ¾Ã­vÃ¡ se to na modifikovÃ¡nÃ­ nebo zakomponovÃ¡nÃ­ libovolnÃ©ho objektu.

`children()`::
  reprezentuje vÅ¡echny pÅ™edanÃ© objekty

`children(n)`::
  reprezentuje _n_-tÃ½ pÅ™edanÃ½ objekt

`children([n1, ..., nx])`::
  reprezentuje _n_-prvnÃ­ aÅ¾ _n_-_x_-tÃ½ pÅ™edanÃ½ objekt

`$children`::
  magickÃ¡ (s dolarem) konstanta s poÄtem pÅ™edanÃ½ch objektÅ¯

`children([1 : 2 : $children])`::
  kaÅ¾dÃ½ druhÃ½ pÅ™edanÃ½ objekt

.PÅ™Ã­klad modulu, kterÃ½ provede s `children()` nÄ›jakou operaci
[source,scad]
----
module elongate() {
  scale([10 , 1, 1])
    children();
}

elongate() {
  sphere(30);
  cube(45, center=true);
  cylinder(r=10, h=50);
}
----

.PÅ™Ã­klad pouÅ¾itÃ­ modulu `elongate()`
image::ex8.png[]

== Debugging

Pro debugging modelÅ¯ je dobbrÃ© nauÄit si nÄ›kolik modifikÃ¡torÅ¯:

`%`::
  kbd:[F5] vykreslÃ­ uzel poloprÅ¯hlednÄ›, kbd:[F6] vÅ¯bec

`#`::
  kbd:[F5] vykreslÃ­ uzel poloprÅ¯hlednÄ› a ÄervenÄ›, kbd:[F6] normÃ¡lnÄ›

`!`::
  kbd:[F5] i kbd:[F6] zobrazÃ­ pouze tento uzel

`*`::
  kbd:[F5] i kbd:[F6] tento uzel bude ignorovat

.ModifikÃ¡tor `#`
[source,scad]
----
difference() {
  sphere(45);
  #cube(65, center=true);
}
----

.ModifikÃ¡tor `#`
image::ex9.png[]

== PomocnÃ­Äci

WARNING: Zde zhruba konÄÃ­ obsah druhÃ©ho cviÄenÃ­ a pokraÄuje obsah tÅ™etÃ­ho.
MateriÃ¡ly nÃ­Å¾e se jeÅ¡tÄ› budou upravovat a jsou zatÃ­m k dispozici pouze v bodech.

* `minkowski()` "objede" prvnÃ­ objekt druhÃ½m, pak pÅ™Ã­padnÄ› tÅ™etÃ­m...
* `hull()` "oplÃ¡Å¡tÃ­" objekty co nejmenÅ¡Ã­m plÃ¡Å¡tÄ›m
* obojÃ­ mÅ¯Å¾e bÃ½t pomÄ›rnÄ› pomalÃ©

[source,scad]
----
minkowski() {
  hull() {
    rotate([120,0,0]) cylinder(h=1,r=10);
    translate([0,30,0]) rotate([-120,0,0]) cylinder(h=1,r=13);
    translate([0,15,25]) cylinder(h=1,r=8);
  }
  sphere(3);
}
----

image::ex5.png[]

== DvourozmÄ›rnÃ½ subsystÃ©m

* je moÅ¾nÃ© vyvÃ¡Å™et 2D primitivy
** `circle()`, `square()`, `polygon()`
** potÃ© `linear_extrude()` nebo `rotate_extrude()`
* `projection()` slouÅ¾Ã­ k projekci 3D objektÅ¯ do 2D
* vÃ­ce info
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Using_the_2D_Subsystem[v
manuÃ¡lu]
* 2D objekty se tvÃ¡Å™Ã­ jako malÃ© ÃºzkÃ© 3D objekty, ale nejdou tak
vyrendrovat

=== 2D primitiva

* `square()` jako alternativa `cube()`
* `circle()` jako alternativa `sphere()`
* `polygon()` jako alternativa `polyhedron()`

=== offset()

* `offset()`
* `r` pro zaoblenÃ© rohy
* `delta` pro Å¡piÄatÃ© rohy
* `chamfer` (bool, jen s `delta`) "uÅ™Ã­zne" rohy

=== linear_extrude()

* vytÃ¡hne 2D tvar do prostoru
* `height` -- vÃ½Å¡ka vytaÅ¾enÃ­
* `center` -- false jede jen nahoru, true na oba smÄ›ry
* `twist` -- o kolik stupÅˆÅ¯ se 2D tvar otoÄÃ­ na `height`
* `slices` -- poÄet krokÅ¯ u `twist`

[source,scad]
----
linear_extrude(height=20,twist=180,slices=100,center=true) {
  square(5);
  square(5,true);
}
----

image::ex11.png[]

=== rotate_extrude()

* rotuje 2D tvar do prostoru
* kolem osy Y, potom "vzpÅ™Ã­menÃ­" na Z
* zÃ¡leÅ¾Ã­ na pozici
* nezÃ¡leÅ¾Ã­ na rotaci

[source,scad]
----
rotate_extrude($fn=200) polygon(points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]]);
----

image::ex10.png[]

=== 2D import

* mÅ¯Å¾ete importovat DXF soubory
* lze
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_2D_formats#SVG[pÅ™evÃ©st
z SVG na DXF]
** zmrÅ¡Ã­ to velikost, je tÅ™eba pouÅ¾Ã­t resize()

[source,scad]
----
rotate_extrude() resize([20,0],[true,true]) import("bottle.dxf");
----

image::ex12.png[]

=== projection()

* promÃ­tne 3D objekt na rovinu XY
* `cut` -- true zobrazÃ­ jen prÅ¯nik s rovinou XY
* vÃ½sledkem je 2D tvar

[source,scad]
----
use </usr/share/openscad/examples/example002.scad>
linear_extrude(20) projection() rotate([90,0,0]) example002();
----

image::ex13.png[]

== import()

* kromÄ› DXF lze importovat i STL soubory
* ne vÅ¾dy se povedou vyrendrovat
** je tÅ™eba je opravit
** viz xref:mesh#[oprava meshe]

[source,scad]
----
difference() {
  import("kangaroo5.stl");
  // http://www.thingiverse.com/thing:33273 CC BY-NC-SA
  translate([0,-10,80]) cube(30,true);
}
----

image::ex14.png[]

== surface()

* `surface(file = "smiley.png", center = true);`

image::surface.png[]

_obrÃ¡zek
https://commons.wikimedia.org/wiki/File:OpenSCAD_surface_example.png[pochÃ¡zÃ­]
z OpenSCAD manuÃ¡lu, autorem je Torsten Paul_

== RozliÅ¡enÃ­

* `$fn`, `$fa` a `$fs` nastavuje rozliÅ¡enÃ­, viz
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#.24fa.2C_.24fs_and_.24fn[manuÃ¡l]
** mÅ¯Å¾e se nastavit globÃ¡lnbÄ›
** nebo uvnitÅ™ chlupatÃ½ch zÃ¡vorek
** mÅ¯Å¾e se pÅ™edat jako parametr Äemukoli -- modulu nebo primitivÄ›

== Simple - 2-Manifold

* pro export STL je potÅ™eba aby byl model 2-Manifold
* skoro vÅ¡e Å™eÅ¡Ã­ vÃ½slednÃ½ `union()`
* problÃ©m: spoleÄnÃ¡ hrana -- nereÃ¡lnÃ©
* jinak lze zanÃ©st chybu polyhedronem

[source,scad]
----
cube(20); translate([20,20,0]) cube(20);
// i=0.0001; cube(20); translate([20-i,20-i,0]) cube(20);
----

image::ex15.png[]

== Knihovna MCAD

* spousta elementÃ¡rnÃ­ch i pokroÄilÃ½ch vÄ›cÃ­
* novÃ© jakoÅ¾e primitivy
* vhodnÃ© vÄ›ci pro RepRap
** motorky
** Å™emeniÄky
* je tÅ™eba `include`, ne `use`!
* https://github.com/elmom/MCAD/blob/master/README.markdown[info]

[source,scad]
----
include <MCAD/stepper.scad>
motor(Nema17);
----

image::ex16.png[]

== PokroÄilÃ¡ prÃ¡ce s promÄ›nnÃ½mi

* xref:openscad/openscad-vars#[pÅ™Ã­klady chovÃ¡nÃ­]

== PÅ™Ã­klady ze cviÄenÃ­

* xref:openscad/openscad-molecule#[molekula]
