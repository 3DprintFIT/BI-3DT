= OpenSCAD
:toc:
:imagesdir: ../images/openscad/
:experimental:
// experimental for the kbd macro

Program http://www.openscad.org/[OpenSCAD] slouží k modelování 3D modelů nejen
pro 3D tiskárny. Je to program umožňující CSG modelování deklarativním
zápisem -- kódem.

.Program OpenSCAD
image::openscad.png[width=555]

Vyčerpávající http://en.wikibooks.org/wiki/OpenSCAD_User_Manual[manuál
v angličtině] použijte jako referenci.


== CSG modelování

http://cs.wikipedia.org/wiki/Constructive_solid_geometry[CSG modelování]
(_Constructive Solid Geometry_) je vektorové modelování grafických prvků,
v našem případě 3D modelů.
Základní *primitiva* (koule, kužel/válec, kvádr…) se skládají do *CSG stromu*
pomocí hran *transformací* (posun, škálování, rotace…)
a uzlů *booleovských operací* (rozdíl, průnik, sloučení).

Na obrázku vidíte ilustraci CSG stromu. Zde jsou pro zjednodušení primitivy
již otočené.

.CSG strom. © http://commons.wikimedia.org/wiki/File:Csg_tree.png[Zottie], GNU FDL
image::csg_tree.png[width=555]

OpenSCAD umožňuje takové stromy zapsat pomocí kódu a vyrendorvat z nich výsledný
3D model ve formě xref:mesh#[triangulární meshe] (o té se budeme učit později).

== Uživatelské rozhraní

Okno programu se skládá ze tří částí:

Editor::
  (vlevo) V něm píšete zdrojový kód modelu.

Náhled::
  (vpravo) 3D plátno, kde uvidíte náhled modelu.

Konzole::
  (vpravo dole) V konzoli je vidět chybový a ladící výstup.

Po napsání kódu do editoru je třeba model „zkompilovat“.
Existuje rychlý (ne vždy přesný) náhled pomocí OpenGL (_Design → Zobrazit_, kbd:[F5])
a plnohodnotný render do 3D modelu pro export (počítá se bohužel na procesoru,
_Design → Vyrenderovat_, kbd:[F6]).
V nabídce _Design_ lze zapnout i _Automaticky načítat a zobrazovat_, po uložení
se pak provede náhled automaticky.

V nabídce _Zobrazit_ najdete spousto možností pro zobrazení náhledu,
doporučujeme zapnout _osy_ a _pravítko_.

Pro pohyb modelem později použijete myš (vyzkoušejte různá tlačítka).

Abyste něco viděli, potřebujete ale zdrojový kód.
Můžete si vybrat z pestré nabídky _Soubor → Příklady_.

== Syntax

Syntaxe je hned na první pohled velmi *podobná C/C++/Javě* --
obsahuje středníky, chlupaté závorky, komentáře se píší stejně.
Kromě jiného můžete psát *čísla*
(buď celá, nebo s plovoucí desetinnou čárkou (zápis pomocí tečky nebo vědecky)) --
`1`, `0`, `-5`, `5.3`, `9.99998`, `185e-5`;
*vektory/souřadnice* v hranatých závorkách --
`[1, 2, 3]`; *řetězce* ve `"dvojitých uvozovkách"`, **boolean** `true`/`false`.

Můžete používat *proměnné* (které se nedeklarují, ale chovají se nestandardně,
k tomu se dostaneme dále), *matematické
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators[výrazy]*
a
*http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Functions[funkce]*,
konstantu `PI`…

WARNING: Nenechte se syntaxí zmást, nejedná se o programovací, ale deskriptivní jazyk!
To znamená, že jednotlivé příkazy a výrazy se nedějí postupně odshora dolů,
ale spolu najednou popisují výsledek -- CSG strom.

TIP: http://www.openscad.org/cheatsheet/[Přehledný tahák.]

== Primitiva

`cube(size, center);`::
  kvádr (`size=[1, 2, 3]`) nebo krychle (`size=5`)

`sphere(r);`::
  koule (lze použít `r` -- poloměr nebo `d` -- průměr)

`cylinder(...);`::
  (komolý) kužel (`h, r1, r2, center`) nebo válec (`h, r, center`)

`polyhedron(...);`::
  mnohostěn, nízkoúrovňová primitiva popisující přímo triangulární mesh

NOTE: Všechny číslice určující rozměr jsou bez jednotky, protože výsledný
3D model také žádné nemá. To umožňuje modelovat vesmírná tělesa či subatomární
částice bez nutnosti používat velmi velké/malé hodnoty.
Pro účely 3D tisku si za číslicemi představujte milimetry.

.Ukázka použití dvou primitiv. V tomto případě se provede _implicitní sloučení_
[source,scad]
----
cube(150, center=true); // <1>
sphere(100); // <2>
----
<1> vycentrovaná krychle o hraně délky 150 (všimněte si, že argumenty se dají předávat pozičně i pomocí jména)
<2> koule o poloměru 100

.Ukázka použití dvou primitiv
image::ex1.png[]

== Transformace

Když už umíte vytvářet primitivní geometrická tělesa, je dobré naučit se s nimi
provádět jednotlivé transformace.

`scale()`::
  škáluje objekt o zadanou konstantu nebo vektor tří hodnot

`resize()`::
  škáluje objekt *na* zadanou velikost

`rotate()`::
  objekt otáčí o úhel zadaný ve stupních, použije se jako
  `rotate([deg,deg,deg])` nebo `rotate(deg,[1,1,0])`

`translate([x, y, z])`::
  relativní posun objektu

`mirror([x, y, z])`::
  překlopí (zrcadlí) objekt podle počátkem procházející roviny se zadaným normálovým vektorem,
  např. `[1, 0, 0]` zrcadlí podle roviny _YZ_; zrcadlený objekt se neduplikuje

`multmatrix([[...]])`::
  transformační matice velikosti 4×4, nízkoúrovňové

`color(...)`::
  obarví objekt zadanou barvou, funguje jen v náhledu

Transformace se aplikují zápisem před objekt, který chcete transformovat:
`transformace() objekt();`. Dají se také řetězit, jsou aplikované postupně od
„nejbližší“ po nejvzdálenější. Dají se aplikovat i na více objektů současně,
zabalením objektů do chlupatých závorek a předsazením před ně.

.Transformace aplikovaná na více objektů současně
[source,scad]
----
transformce() {
  objekt1();
  objekt2();
}
----

IMPORTANT: Veškeré operace (snad kromě barvy) se dějí *kolem počátku souřadnic*.
Např. pokud objekt leží někde mimo počátek a vy jej otočíte, jeho poloha se změní.

.Na pořadí operací záleží
[source,scad]
----
color("green") rotate([0,0,60]) translate([30,0,0]) cube(5); // <1>
color("red") translate([30,0,0]) rotate([0,0,60]) cube(5); // <2>
----
<1> Kostka se nejprve posune, poté otočí kolem počátku a nakonec obarví
<2> Kostka se nejprve otočí kolem počátku, poté posune a nakonec obarví

.Na pořadí operací záleží
image::ex2.png[]

== Booleovské operace

Základem CSG modelování jsou tři boolovské operace:

`union()` -- sloučení::
  z více objektů udělá jeden
  (pokud by měl mít výsledný CSG strom více kořenů, provede se na nich implicitně)

`difference()` -- rozdíl::
  od prvního objektu odečte všechny další

`intersection()` -- průnik::
  zůstane pouze společná část všech objektů

.Sloučení (to by se zde provedlo implicitně, ale jinde přijde vhod)
[source,scad]
----
union() {
  cube(150, center=true);
  sphere(100);
}
----

.Sloučení
image::ex1.png[]

.Rozdíl
[source,scad]
----
difference() {
  cube(150, center=true);
  sphere(100);
}
----

.Rozdíl
image::ex3.png[]

.Průnik
[source,scad]
----
intersection() {
  cube(150, center=true);
  sphere(100);
}
----

.Průnik
image::ex4.png[]

Všechny tyto operace nemají žádné argumenty, ale zpracují libovolný počet objektů.
Takovým objektům se říká *children* dané operace.
Česky to znamená _děti_, ale my tento pojem raději překládat nebudeme.

== Použití proměnných

Není nutné všude používat hodnoty přímo, v OpenSCADu se dají používat i proměnné.

.Použití proměnné
[source,scad]
----
awesome = 42;
cylinder(h=awesome, r=awesome/2);
----

Mějte ale na paměti fakt, že *všechno se děje zároveň*.
Proměnou proto nelze předefinovat, respektive lze, ale chová se to jinak,
než jste zvyklí.

.Proměnnou lze předefinovat, ale neuvěříte, co se stane
[source,scad]
----
awesome = 42;
echo(awesome); // <1>
awesome = 4242; // <2>
echo(awesome);
----
<1> funkce echo vypisuje ladící informace do konzole
<2> přenastavení, co se stane?

Výsledkem je dvakrát vypsané `ECHO: 4242` 🤯
Důvodem je to, že nezáleží, kdy proměnnou nastavíte, její hodnota platí v celém
scopu. Pokud proměnnou nastavíte v jednom scopu dvakrát, platí později uvedená
hodnota, to berte ale jen jako implementační detail a *nikdy to nedělejte*.

WARNING: Ze stejného důvodu nemůžete použít `a = a + 1;` a syntaxe pro
`a += 1;` ani neexistuje (jedná se o syntaktickou chybu).

Pomůže *o proměnných uvažovat jako o konstantách* pro daný scope.
Zatím známe jen jeden (globální) scope, ale to se brzy změní.

== Cykly

[quote, Forrestova máma]
Two or more, use a for.

Syntaxe foru je kapku odlišná od C a vypadá asi takto:

.Syntax cyklu for
[source,scad]
----
for (var = [...]) { // <1>
    ... // <2>
}
----
<1> hlavička cyklu, do proměnné přiřadíme vektor
<2> v těle cyklu proměnná `var` nabývá hodnot z použitého vektoru

Zastavme se na chvíli u zápisu vektorů, které jde zapsat několika způsoby:

výčtem::
  `var = [-1, 1]` -- hodnoty -1 a 1

intervalem::
  `var = [0 : 5]` -- celá čísla od 0 do 5, obě meze jsou použity

intervalem se skokem::
  `var = [0 : 0.2 : 5]` -- hodnoty od 0 do 5 (včetně), použije se krok 0,2

Toho často využijeme v zápisu cyklu for.

.Cyklus s intervalem
[source,scad]
----
for (i = [0:10:100]) echo(i); // => ECHO 10, 20, 30...
----

NOTE: Pozorný čtenář si teď řekne, jak je možné, že nám tady něco cyklí a
postupně něco dělá, když se všechno děje najednou.
For zde vytvoří několik odnoží CSG stromu, každou s vlastním scopem,
aby mohla být hodnota proměnné jiná, a *na výsledku provede sjednocení*.
Jednotlivé hodnoty z ladícího výpisu vidíte postupně, protože jinak to nejde.

.intersection_for je speciální varianta foru, která neprovádí sjednocení, ale průnik
[source,scad]
----
intersection_for(n = [1 : 6]) {
  rotate([0,0,n*60]) translate([5,0,0]) sphere(12);
}
----

.intersection_for
image::ex6.png[]

Cykly lze samozřejmě do sebe vnořovat, existuje k tomu i zkratka.

.Vnořené cykly
[source,scad]
----
for (xpos=[0:3]) {
  for (ypos=[2,4,6]) { // <1>
    ...
  }
}

for (xpos=[0:3], ypos=[2,4,6]) { // <2>
  ...
}
----
{nbsp}
// we put in {nbsp} for
// https://gitlab.fit.cvut.cz/course-pages/course-pages/issues/102

<1> Vnořený cyklus
<2> Zkratka (_syntactic sugar_) pro vnořený cyklus

Vzhledem k tomu, jak cyklus for v OpenSCADu funguje, zde vypichujeme několik
informací, na které pozorný čtenář jistě již přišel sám:

* Každá „iterace“ cyklu má vlastní cope, jakékoliv nastavení proměnných
  v další iteraci (a také po skončení cyklu) pozbývá platnosti.
* Z předchozího bodu plyne, že v cyklu se nedá nic iterativně počítat,
  je možné pouze použít matematické výrazy s řídící proměnnou.
* Cyklus while nedává v OpenSCADu smysl a tedy neexistuje.

== Podmínky

OpenSCAD obsahuje dva druhy podmínek: *if* a *ternární operátor*.

=== if, else if, else

Syntaxe podmínky if není překvapující (chlupaté závorky jsou volitelné):

.Syntax podmínky if
[source,scad]
----
if (...) { // <1>
  ... // <2>
} else if (...) { // <3>
  ... // <4>
} else { // <5>
  ... // <6>
}
----
<1> pravdivostní výraz (např. `a > b`, `0`, `true`, `len(vec) != 42`)
<2> vlastní scope!
<3> volitelná větev s jinou podmínkou
<4> vlastní scope!
<5> volitelná větev, když žádná podmínka neplatí
<6> vlastní scope!

Jednotlivé větve podmínky *mají vlastní scope*.
To znamená, že není následující kód může mít pro někoho překvapující výsledek:

.Na tohle se studenti vždy nachytají, ptali bychom se na to u zkoušky, kdybychom nějakou měli
[source,scad]
----
num = 42;

if (num > 0) {
  sign = 1;
} else if (num < 0) {
  sign = -1;
} else {
  sign = 0;
}

echo(sign); // WARNING: Ignoring unknown variable 'sign'.
----

Tuto vlastnost OpenSCADu lze obejít jedině ternárním operátorem.

=== Ternární operátor

Ternární operátor, je jediný způsob,
jak nastavit nějakou hodnotu s dlouhodobou platností.

.Ternární operátor
[source,scad]
----
num = 42;

// var =   test ? TrueValue : FalseValue;

sign = num > 0 ? 1 : (num < 0 ? -1 : 0); // <1>
echo(sign); // ECHO: 1
----
<1> Zde noříme operátory do sebe

== Funkce

Podobně jako ternární operátor se zapisují funkce. Funkce nevytváří části CSG
stromu, pouze počítají nějakou hodnotu ze svého vstupu.
Jsou to jednovýrazové zkratky.

[source,scad]
function name ( parameters ) = expression;

Funkcemi se v tomto kurzu moc nezabýváme,
ale zvídaví studenti je mohou samozřejmě používat.
https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#Functions[Více o funkcích v manuálu].

== Moduly

Ekvivalentem k funkci pro CSG strom je *modul*.
Modul se více podobá funkcím, jak je známe z programovacích jazyků,
s tím rozdílem, že nevrací žádnou hodnotu, ale uzel (či hranu) CSG stromu.

Laicky řečeno: model něco „nakreslí“ tam, kde se použije.

Stejně jako funkce, přijímá model parametry,
které mohou nabývat výchozích hodnot.
Navíc může přijímat (zpracovávat) `children()`.

Moduly (a funkce) mohou existovat v samostatných souborech (knihovnách),
ve vlastním souboru s modelem můžete použít `use` nebo
`include`:

`use <lib.scad>;`::
  dá k dispozici moduly a funkce ze souboru `lib.scad`

`include <lib.scad>;`::
  na místo vloží celý soubor `lib.scad` (případné objekty se rovnou vykreslí)

.Příklad vlastního modulu (válec s kulatými konci)
[source,scad]
----
module rounded_cylinder(h=20, r=5, center=false) {
  baseh = h-2*r;
  translate([0, 0, center ? -baseh/2 : r]) {
    cylinder(h=baseh, r=r);
    sphere(r);
    translate([0, 0, baseh]) sphere(r);
  }
}

// pro zobrazení musíte modul zavolat
rounded_cylinder(center=true);
----

.Válec s kulatými konci
image::ex7.png[]

=== children()

Kromě modulů, které vytvářejí tvary jen na základě vstupních parametrů
(argumentů), jdou vytvářet i moduly, které přijímají `children()`.

Používá se to na modifikování nebo zakomponování libovolného objektu.

`children()`::
  reprezentuje všechny předané objekty

`children(n)`::
  reprezentuje _n_-tý předaný objekt

`children([n1, ..., nx])`::
  reprezentuje _n_-první až _n_-_x_-tý předaný objekt

`$children`::
  magická (s dolarem) konstanta s počtem předaných objektů

`children([1 : 2 : $children])`::
  každý druhý předaný objekt

.Příklad modulu, který provede s `children()` nějakou operaci
[source,scad]
----
module elongate() {
  scale([10 , 1, 1])
    children();
}

elongate() {
  sphere(30);
  cube(45, center=true);
  cylinder(r=10, h=50);
}
----

.Příklad použití modulu `elongate()`
image::ex8.png[]

== Debugging

Pro debugging modelů je dobbré naučit si několik modifikátorů:

`%`::
  kbd:[F5] vykreslí uzel poloprůhledně, kbd:[F6] vůbec

`#`::
  kbd:[F5] vykreslí uzel poloprůhledně a červeně, kbd:[F6] normálně

`!`::
  kbd:[F5] i kbd:[F6] zobrazí pouze tento uzel

`*`::
  kbd:[F5] i kbd:[F6] tento uzel bude ignorovat

.Modifikátor `#`
[source,scad]
----
difference() {
  sphere(45);
  #cube(65, center=true);
}
----

.Modifikátor `#`
image::ex9.png[]

== Pomocníčci

WARNING: Zde zhruba končí obsah druhého cvičení a pokračuje obsah třetího.
Materiály níže se ještě budou upravovat a jsou zatím k dispozici pouze v bodech.

* `minkowski()` "objede" první objekt druhým, pak případně třetím...
* `hull()` "opláští" objekty co nejmenším pláštěm
* obojí může být poměrně pomalé

[source,scad]
----
minkowski() {
  hull() {
    rotate([120,0,0]) cylinder(h=1,r=10);
    translate([0,30,0]) rotate([-120,0,0]) cylinder(h=1,r=13);
    translate([0,15,25]) cylinder(h=1,r=8);
  }
  sphere(3);
}
----

image::ex5.png[]

== Dvourozměrný subsystém

* je možné vyvářet 2D primitivy
** `circle()`, `square()`, `polygon()`
** poté `linear_extrude()` nebo `rotate_extrude()`
* `projection()` slouží k projekci 3D objektů do 2D
* více info
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Using_the_2D_Subsystem[v
manuálu]
* 2D objekty se tváří jako malé úzké 3D objekty, ale nejdou tak
vyrendrovat

=== 2D primitiva

* `square()` jako alternativa `cube()`
* `circle()` jako alternativa `sphere()`
* `polygon()` jako alternativa `polyhedron()`

=== offset()

* `offset()`
* `r` pro zaoblené rohy
* `delta` pro špičaté rohy
* `chamfer` (bool, jen s `delta`) "uřízne" rohy

=== linear_extrude()

* vytáhne 2D tvar do prostoru
* `height` -- výška vytažení
* `center` -- false jede jen nahoru, true na oba směry
* `twist` -- o kolik stupňů se 2D tvar otočí na `height`
* `slices` -- počet kroků u `twist`

[source,scad]
----
linear_extrude(height=20,twist=180,slices=100,center=true) {
  square(5);
  square(5,true);
}
----

image::ex11.png[]

=== rotate_extrude()

* rotuje 2D tvar do prostoru
* kolem osy Y, potom "vzpřímení" na Z
* záleží na pozici
* nezáleží na rotaci

[source,scad]
----
rotate_extrude($fn=200) polygon(points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]]);
----

image::ex10.png[]

=== 2D import

* můžete importovat DXF soubory
* lze
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_2D_formats#SVG[převést
z SVG na DXF]
** zmrší to velikost, je třeba použít resize()

[source,scad]
----
rotate_extrude() resize([20,0],[true,true]) import("bottle.dxf");
----

image::ex12.png[]

=== projection()

* promítne 3D objekt na rovinu XY
* `cut` -- true zobrazí jen průnik s rovinou XY
* výsledkem je 2D tvar

[source,scad]
----
use </usr/share/openscad/examples/example002.scad>
linear_extrude(20) projection() rotate([90,0,0]) example002();
----

image::ex13.png[]

== import()

* kromě DXF lze importovat i STL soubory
* ne vždy se povedou vyrendrovat
** je třeba je opravit
** viz xref:mesh#[oprava meshe]

[source,scad]
----
difference() {
  import("kangaroo5.stl");
  // http://www.thingiverse.com/thing:33273 CC BY-NC-SA
  translate([0,-10,80]) cube(30,true);
}
----

image::ex14.png[]

== surface()

* `surface(file = "smiley.png", center = true);`

image::surface.png[]

_obrázek
https://commons.wikimedia.org/wiki/File:OpenSCAD_surface_example.png[pochází]
z OpenSCAD manuálu, autorem je Torsten Paul_

== Rozlišení

* `$fn`, `$fa` a `$fs` nastavuje rozlišení, viz
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#.24fa.2C_.24fs_and_.24fn[manuál]
** může se nastavit globálnbě
** nebo uvnitř chlupatých závorek
** může se předat jako parametr čemukoli -- modulu nebo primitivě

== Simple - 2-Manifold

* pro export STL je potřeba aby byl model 2-Manifold
* skoro vše řeší výsledný `union()`
* problém: společná hrana -- nereálné
* jinak lze zanést chybu polyhedronem

[source,scad]
----
cube(20); translate([20,20,0]) cube(20);
// i=0.0001; cube(20); translate([20-i,20-i,0]) cube(20);
----

image::ex15.png[]

== Knihovna MCAD

* spousta elementárních i pokročilých věcí
* nové jakože primitivy
* vhodné věci pro RepRap
** motorky
** řemeničky
* je třeba `include`, ne `use`!
* https://github.com/elmom/MCAD/blob/master/README.markdown[info]

[source,scad]
----
include <MCAD/stepper.scad>
motor(Nema17);
----

image::ex16.png[]

== Pokročilá práce s proměnnými

* xref:openscad/openscad-vars#[příklady chování]

== Příklady ze cvičení

* xref:openscad/openscad-molecule#[molekula]
