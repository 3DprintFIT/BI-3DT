= OpenSCAD
:toc:
:imagesdir: ../images/openscad/
:experimental:
// experimental for the kbd macro

Program http://www.openscad.org/[OpenSCAD] slouÅ¾Ã­ k modelovÃ¡nÃ­ 3D modelÅ¯ nejen
pro 3D tiskÃ¡rny. Je to program umoÅ¾ÅˆujÃ­cÃ­ CSG modelovÃ¡nÃ­ deklarativnÃ­m
zÃ¡pisem -- kÃ³dem.

.Program OpenSCAD
image::openscad.png[width=555]

VyÄerpÃ¡vajÃ­cÃ­ http://en.wikibooks.org/wiki/OpenSCAD_User_Manual[manuÃ¡l
v angliÄtinÄ›] pouÅ¾ijte jako referenci.


== CSG modelovÃ¡nÃ­

http://cs.wikipedia.org/wiki/Constructive_solid_geometry[CSG modelovÃ¡nÃ­]
(_Constructive Solid Geometry_) je vektorovÃ© modelovÃ¡nÃ­ grafickÃ½ch prvkÅ¯,
v naÅ¡em pÅ™Ã­padÄ› 3D modelÅ¯.
ZÃ¡kladnÃ­ *primitiva* (koule, kuÅ¾el/vÃ¡lec, kvÃ¡drâ€¦) se sklÃ¡dajÃ­ do *CSG stromu*
pomocÃ­ hran *transformacÃ­* (posun, Å¡kÃ¡lovÃ¡nÃ­, rotaceâ€¦)
a uzlÅ¯ *booleovskÃ½ch operacÃ­* (rozdÃ­l, prÅ¯nik, slouÄenÃ­).

Na obrÃ¡zku vidÃ­te ilustraci CSG stromu. Zde jsou pro zjednoduÅ¡enÃ­ primitivy
jiÅ¾ otoÄenÃ©.

.CSG strom. Â© http://commons.wikimedia.org/wiki/File:Csg_tree.png[Zottie], GNU FDL
image::csg_tree.png[width=555]

OpenSCAD umoÅ¾Åˆuje takovÃ© stromy zapsat pomocÃ­ kÃ³du a vyrenderovat z nich vÃ½slednÃ½
3D model ve formÄ› xref:mesh#[triangulÃ¡rnÃ­ meshe] (o tÃ© se budeme uÄit pozdÄ›ji).

== UÅ¾ivatelskÃ© rozhranÃ­

Okno programu se sklÃ¡dÃ¡ ze tÅ™Ã­ ÄÃ¡stÃ­:

Editor::
  (vlevo) V nÄ›m pÃ­Å¡ete zdrojovÃ½ kÃ³d modelu.

NÃ¡hled::
  (vpravo) 3D plÃ¡tno, kde uvidÃ­te nÃ¡hled modelu.

Konzole::
  (vpravo dole) V konzoli je vidÄ›t chybovÃ½ a ladÃ­cÃ­ vÃ½stup.

Po napsÃ¡nÃ­ kÃ³du do editoru je tÅ™eba model â€zkompilovatâ€œ.
Existuje rychlÃ½ (ne vÅ¾dy pÅ™esnÃ½) nÃ¡hled pomocÃ­ OpenGL (_Design â†’ Zobrazit_, kbd:[F5])
a plnohodnotnÃ½ render do 3D modelu pro export (poÄÃ­tÃ¡ se bohuÅ¾el na procesoru,
_Design â†’ Vyrenderovat_, kbd:[F6]).
V nabÃ­dce _Design_ lze zapnout i _Automaticky naÄÃ­tat a zobrazovat_, po uloÅ¾enÃ­
se pak provede nÃ¡hled automaticky.

V nabÃ­dce _Zobrazit_ najdete spousto moÅ¾nostÃ­ pro zobrazenÃ­ nÃ¡hledu,
doporuÄujeme zapnout _osy_ a _pravÃ­tko_.

Pro pohyb modelem pozdÄ›ji pouÅ¾ijete myÅ¡ (vyzkouÅ¡ejte rÅ¯znÃ¡ tlaÄÃ­tka).

Abyste nÄ›co vidÄ›li, potÅ™ebujete ale zdrojovÃ½ kÃ³d.
MÅ¯Å¾ete si vybrat z pestrÃ© nabÃ­dky _Soubor â†’ PÅ™Ã­klady_.

== Syntax

Syntaxe je hned na prvnÃ­ pohled velmi *podobnÃ¡ C/C++/JavÄ›* --
obsahuje stÅ™ednÃ­ky, chlupatÃ© zÃ¡vorky, komentÃ¡Å™e se pÃ­Å¡Ã­ stejnÄ›.
KromÄ› jinÃ©ho mÅ¯Å¾ete psÃ¡t *ÄÃ­sla*
(buÄ celÃ¡, nebo s plovoucÃ­ desetinnou ÄÃ¡rkou (zÃ¡pis pomocÃ­ teÄky nebo vÄ›decky)) --
`1`, `0`, `-5`, `5.3`, `9.99998`, `185e-5`;
*vektory/souÅ™adnice* v hranatÃ½ch zÃ¡vorkÃ¡ch --
`[1, 2, 3]`; *Å™etÄ›zce* ve `"dvojitÃ½ch uvozovkÃ¡ch"`, **boolean** `true`/`false`.

MÅ¯Å¾ete pouÅ¾Ã­vat *promÄ›nnÃ©* (kterÃ© se nedeklarujÃ­, ale chovajÃ­ se nestandardnÄ›,
k tomu se dostaneme dÃ¡le), *matematickÃ©
http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators[vÃ½razy]*
a
*http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Functions[funkce]*,
konstantu `PI`â€¦

WARNING: Nenechte se syntaxÃ­ zmÃ¡st, nejednÃ¡ se o programovacÃ­, ale deskriptivnÃ­ jazyk!
To znamenÃ¡, Å¾e jednotlivÃ© pÅ™Ã­kazy a vÃ½razy se nedÄ›jÃ­ postupnÄ› odshora dolÅ¯,
ale spolu najednou popisujÃ­ vÃ½sledek -- CSG strom.

TIP: http://www.openscad.org/cheatsheet/[PÅ™ehlednÃ½ tahÃ¡k.]

== Primitiva

`cube(size, center);`::
  kvÃ¡dr (`size=[1, 2, 3]`) nebo krychle (`size=5`)

`sphere(r);`::
  koule (lze pouÅ¾Ã­t `r` -- polomÄ›r nebo `d` -- prÅ¯mÄ›r)

`cylinder(...);`::
  (komolÃ½) kuÅ¾el (`h, r1, r2, center`) nebo vÃ¡lec (`h, r, center`)

`polyhedron(...);`::
  mnohostÄ›n, nÃ­zkoÃºrovÅˆovÃ¡ primitiva popisujÃ­cÃ­ pÅ™Ã­mo triangulÃ¡rnÃ­ mesh

NOTE: VÅ¡echny ÄÃ­slice urÄujÃ­cÃ­ rozmÄ›r jsou bez jednotky, protoÅ¾e vÃ½slednÃ½
3D model takÃ© Å¾Ã¡dnÃ© nemÃ¡. To umoÅ¾Åˆuje modelovat vesmÃ­rnÃ¡ tÄ›lesa Äi subatomÃ¡rnÃ­
ÄÃ¡stice bez nutnosti pouÅ¾Ã­vat velmi velkÃ©/malÃ© hodnoty.
Pro ÃºÄely 3D tisku si za ÄÃ­slicemi pÅ™edstavujte milimetry.

.UkÃ¡zka pouÅ¾itÃ­ dvou primitiv. V tomto pÅ™Ã­padÄ› se provede _implicitnÃ­ slouÄenÃ­_
[source,scad]
----
cube(150, center=true); // <1>
sphere(100); // <2>
----
<1> vycentrovanÃ¡ krychle o hranÄ› dÃ©lky 150 (vÅ¡imnÄ›te si, Å¾e argumenty se dajÃ­ pÅ™edÃ¡vat poziÄnÄ› i pomocÃ­ jmÃ©na)
<2> koule o polomÄ›ru 100

.UkÃ¡zka pouÅ¾itÃ­ dvou primitiv
image::ex1.png[]

== Transformace

KdyÅ¾ uÅ¾ umÃ­te vytvÃ¡Å™et primitivnÃ­ geometrickÃ¡ tÄ›lesa, je dobrÃ© nauÄit se s nimi
provÃ¡dÄ›t jednotlivÃ© transformace.

`scale()`::
  Å¡kÃ¡luje objekt o zadanou konstantu nebo vektor tÅ™Ã­ hodnot

`resize()`::
  Å¡kÃ¡luje objekt *na* zadanou velikost

`rotate()`::
  objekt otÃ¡ÄÃ­ o Ãºhel zadanÃ½ ve stupnÃ­ch, pouÅ¾ije se jako
  `rotate([deg,deg,deg])` nebo `rotate(deg,[1,1,0])`

`translate([x, y, z])`::
  relativnÃ­ posun objektu

`mirror([x, y, z])`::
  pÅ™eklopÃ­ (zrcadlÃ­) objekt podle poÄÃ¡tkem prochÃ¡zejÃ­cÃ­ roviny se zadanÃ½m normÃ¡lovÃ½m vektorem,
  napÅ™. `[1, 0, 0]` zrcadlÃ­ podle roviny _YZ_; zrcadlenÃ½ objekt se neduplikuje

`multmatrix([[...]])`::
  transformaÄnÃ­ matice velikosti 4Ã—4, nÃ­zkoÃºrovÅˆovÃ©

`color(...)`::
  obarvÃ­ objekt zadanou barvou, funguje jen v nÃ¡hledu

Transformace se aplikujÃ­ zÃ¡pisem pÅ™ed objekt, kterÃ½ chcete transformovat:
`transformace() objekt();`. DajÃ­ se takÃ© Å™etÄ›zit, jsou aplikovanÃ© postupnÄ› od
â€nejbliÅ¾Å¡Ã­â€œ po nejvzdÃ¡lenÄ›jÅ¡Ã­. DajÃ­ se aplikovat i na vÃ­ce objektÅ¯ souÄasnÄ›,
zabalenÃ­m objektÅ¯ do chlupatÃ½ch zÃ¡vorek a pÅ™edsazenÃ­m pÅ™ed nÄ›.

.Transformace aplikovanÃ¡ na vÃ­ce objektÅ¯ souÄasnÄ›
[source,scad]
----
transformace() {
  objekt1();
  objekt2();
}
----

IMPORTANT: VeÅ¡kerÃ© operace (snad kromÄ› barvy) se dÄ›jÃ­ *kolem poÄÃ¡tku souÅ™adnic*.
NapÅ™. pokud objekt leÅ¾Ã­ nÄ›kde mimo poÄÃ¡tek a vy jej otoÄÃ­te, jeho poloha se zmÄ›nÃ­.

.Na poÅ™adÃ­ operacÃ­ zÃ¡leÅ¾Ã­
[source,scad]
----
color("green") rotate([0,0,60]) translate([30,0,0]) cube(5); // <1>
color("red") translate([30,0,0]) rotate([0,0,60]) cube(5); // <2>
----
<1> Kostka se nejprve posune, potÃ© otoÄÃ­ kolem poÄÃ¡tku a nakonec obarvÃ­
<2> Kostka se nejprve otoÄÃ­ kolem poÄÃ¡tku, potÃ© posune a nakonec obarvÃ­

.Na poÅ™adÃ­ operacÃ­ zÃ¡leÅ¾Ã­
image::ex2.png[]

== BooleovskÃ© operace

ZÃ¡kladem CSG modelovÃ¡nÃ­ jsou tÅ™i boolovskÃ© operace:

`union()` -- slouÄenÃ­::
  z vÃ­ce objektÅ¯ udÄ›lÃ¡ jeden
  (pokud by mÄ›l mÃ­t vÃ½slednÃ½ CSG strom vÃ­ce koÅ™enÅ¯, provede se na nich implicitnÄ›)

`difference()` -- rozdÃ­l::
  od prvnÃ­ho objektu odeÄte vÅ¡echny dalÅ¡Ã­

`intersection()` -- prÅ¯nik::
  zÅ¯stane pouze spoleÄnÃ¡ ÄÃ¡st vÅ¡ech objektÅ¯

.SlouÄenÃ­ (to by se zde provedlo implicitnÄ›, ale jinde pÅ™ijde vhod)
[source,scad]
----
union() {
  cube(150, center=true);
  sphere(100);
}
----

.SlouÄenÃ­
image::ex1.png[]

.RozdÃ­l
[source,scad]
----
difference() {
  cube(150, center=true);
  sphere(100);
}
----

.RozdÃ­l
image::ex3.png[]

.PrÅ¯nik
[source,scad]
----
intersection() {
  cube(150, center=true);
  sphere(100);
}
----

.PrÅ¯nik
image::ex4.png[]

VÅ¡echny tyto operace nemajÃ­ Å¾Ã¡dnÃ© argumenty, ale zpracujÃ­ libovolnÃ½ poÄet objektÅ¯.
TakovÃ½m objektÅ¯m se Å™Ã­kÃ¡ *children* danÃ© operace.
ÄŒesky to znamenÃ¡ _dÄ›ti_, ale my tento pojem radÄ›ji pÅ™eklÃ¡dat nebudeme.

== PouÅ¾itÃ­ promÄ›nnÃ½ch

NenÃ­ nutnÃ© vÅ¡ude pouÅ¾Ã­vat hodnoty pÅ™Ã­mo, v OpenSCADu se dajÃ­ pouÅ¾Ã­vat i promÄ›nnÃ©.

.PouÅ¾itÃ­ promÄ›nnÃ©
[source,scad]
----
awesome = 42;
cylinder(h=awesome, r=awesome/2);
----

MÄ›jte ale na pamÄ›ti fakt, Å¾e *vÅ¡echno se dÄ›je zÃ¡roveÅˆ*.
PromÄ›nou proto nelze pÅ™edefinovat, respektive lze, ale chovÃ¡ se to jinak,
neÅ¾ jste zvyklÃ­.

.PromÄ›nnou lze pÅ™edefinovat, ale neuvÄ›Å™Ã­te, co se stane
[source,scad]
----
awesome = 42;
echo(awesome); // <1>
awesome = 4242; // <2>
echo(awesome);
----
<1> funkce echo vypisuje ladÃ­cÃ­ informace do konzole
<2> pÅ™enastavenÃ­, co se stane?

VÃ½sledkem je dvakrÃ¡t vypsanÃ© `ECHO: 4242` ğŸ¤¯
DÅ¯vodem je to, Å¾e nezÃ¡leÅ¾Ã­, kdy promÄ›nnou nastavÃ­te, jejÃ­ hodnota platÃ­ v celÃ©m
scopu. Pokud promÄ›nnou nastavÃ­te v jednom scopu dvakrÃ¡t, platÃ­ pozdÄ›ji uvedenÃ¡
hodnota, to berte ale jen jako implementaÄnÃ­ detail a *nikdy to nedÄ›lejte*.

WARNING: Ze stejnÃ©ho dÅ¯vodu nemÅ¯Å¾ete pouÅ¾Ã­t `a = a + 1;` a syntaxe pro
`a += 1;` ani neexistuje (jednÃ¡ se o syntaktickou chybu).

PomÅ¯Å¾e *o promÄ›nnÃ½ch uvaÅ¾ovat jako o konstantÃ¡ch* pro danÃ½ scope.
ZatÃ­m znÃ¡me jen jeden (globÃ¡lnÃ­) scope, ale to se brzy zmÄ›nÃ­.

== Cykly

[quote, Forrestova mÃ¡ma]
Two or more, use a for.

Syntaxe foru je kapku odliÅ¡nÃ¡ od C a vypadÃ¡ asi takto:

.Syntax cyklu for
[source,scad]
----
for (var = [...]) { // <1>
    ... // <2>
}
----
<1> hlaviÄka cyklu, do promÄ›nnÃ© pÅ™iÅ™adÃ­me vektor
<2> v tÄ›le cyklu promÄ›nnÃ¡ `var` nabÃ½vÃ¡ hodnot z pouÅ¾itÃ©ho vektoru

Zastavme se na chvÃ­li u zÃ¡pisu vektorÅ¯, kterÃ© jde zapsat nÄ›kolika zpÅ¯soby:

vÃ½Ätem::
  `var = [-1, 1]` -- hodnoty -1 a 1

intervalem::
  `var = [0 : 5]` -- celÃ¡ ÄÃ­sla od 0 do 5, obÄ› meze jsou pouÅ¾ity

intervalem se skokem::
  `var = [0 : 0.2 : 5]` -- hodnoty od 0 do 5 (vÄetnÄ›), pouÅ¾ije se krok 0,2

Toho Äasto vyuÅ¾ijeme v zÃ¡pisu cyklu for.

.Cyklus s intervalem
[source,scad]
----
for (i = [0:10:100]) echo(i); // => ECHO 10, 20, 30...
----

NOTE: PozornÃ½ ÄtenÃ¡Å™ si teÄ Å™ekne, jak je moÅ¾nÃ©, Å¾e nÃ¡m tady nÄ›co cyklÃ­ a
postupnÄ› nÄ›co dÄ›lÃ¡, kdyÅ¾ se vÅ¡echno dÄ›je najednou.
For zde vytvoÅ™Ã­ nÄ›kolik odnoÅ¾Ã­ CSG stromu, kaÅ¾dou s vlastnÃ­m scopem,
aby mohla bÃ½t hodnota promÄ›nnÃ© jinÃ¡, a *na vÃ½sledku provede sjednocenÃ­*.
JednotlivÃ© hodnoty z ladÃ­cÃ­ho vÃ½pisu vidÃ­te postupnÄ›, protoÅ¾e jinak to nejde.

.intersection_for je speciÃ¡lnÃ­ varianta foru, kterÃ¡ neprovÃ¡dÃ­ sjednocenÃ­, ale prÅ¯nik
[source,scad]
----
intersection_for(n = [1 : 6]) {
  rotate([0,0,n*60]) translate([5,0,0]) sphere(12);
}
----

.intersection_for
image::ex6.png[]

Cykly lze samozÅ™ejmÄ› do sebe vnoÅ™ovat, existuje k tomu i zkratka.

.VnoÅ™enÃ© cykly
[source,scad]
----
for (xpos=[0:3]) {
  for (ypos=[2,4,6]) { // <1>
    ...
  }
}

for (xpos=[0:3], ypos=[2,4,6]) { // <2>
  ...
}
----
{nbsp}
// we put in {nbsp} for
// https://gitlab.fit.cvut.cz/course-pages/course-pages/issues/102

<1> VnoÅ™enÃ½ cyklus
<2> Zkratka (_syntactic sugar_) pro vnoÅ™enÃ½ cyklus

Vzhledem k tomu, jak cyklus for v OpenSCADu funguje, zde vypichujeme nÄ›kolik
informacÃ­, na kterÃ© pozornÃ½ ÄtenÃ¡Å™ jistÄ› jiÅ¾ pÅ™iÅ¡el sÃ¡m:

* KaÅ¾dÃ¡ â€iteraceâ€œ cyklu mÃ¡ vlastnÃ­ cope, jakÃ©koliv nastavenÃ­ promÄ›nnÃ½ch
  v dalÅ¡Ã­ iteraci (a takÃ© po skonÄenÃ­ cyklu) pozbÃ½vÃ¡ platnosti.
* Z pÅ™edchozÃ­ho bodu plyne, Å¾e v cyklu se nedÃ¡ nic iterativnÄ› poÄÃ­tat,
  je moÅ¾nÃ© pouze pouÅ¾Ã­t matematickÃ© vÃ½razy s Å™Ã­dÃ­cÃ­ promÄ›nnou.
* Cyklus while nedÃ¡vÃ¡ v OpenSCADu smysl a tedy neexistuje.

== PodmÃ­nky

OpenSCAD obsahuje dva druhy podmÃ­nek: *if* a *ternÃ¡rnÃ­ operÃ¡tor*.

=== if, else if, else

Syntaxe podmÃ­nky if nenÃ­ pÅ™ekvapujÃ­cÃ­ (chlupatÃ© zÃ¡vorky jsou volitelnÃ©):

.Syntax podmÃ­nky if
[source,scad]
----
if (...) { // <1>
  ... // <2>
} else if (...) { // <3>
  ... // <4>
} else { // <5>
  ... // <6>
}
----
<1> pravdivostnÃ­ vÃ½raz (napÅ™. `a > b`, `0`, `true`, `len(vec) != 42`)
<2> vlastnÃ­ scope!
<3> volitelnÃ¡ vÄ›tev s jinou podmÃ­nkou
<4> vlastnÃ­ scope!
<5> volitelnÃ¡ vÄ›tev, kdyÅ¾ Å¾Ã¡dnÃ¡ podmÃ­nka neplatÃ­
<6> vlastnÃ­ scope!

JednotlivÃ© vÄ›tve podmÃ­nky *majÃ­ vlastnÃ­ scope*.
To znamenÃ¡, Å¾e nenÃ­ nÃ¡sledujÃ­cÃ­ kÃ³d mÅ¯Å¾e mÃ­t pro nÄ›koho pÅ™ekvapujÃ­cÃ­ vÃ½sledek:

.Na tohle se studenti vÅ¾dy nachytajÃ­, ptali bychom se na to u zkouÅ¡ky, kdybychom nÄ›jakou mÄ›li
[source,scad]
----
num = 42;

if (num > 0) {
  sign = 1;
} else if (num < 0) {
  sign = -1;
} else {
  sign = 0;
}

echo(sign); // WARNING: Ignoring unknown variable 'sign'.
----

Tuto vlastnost OpenSCADu lze obejÃ­t jedinÄ› ternÃ¡rnÃ­m operÃ¡torem.

=== TernÃ¡rnÃ­ operÃ¡tor

TernÃ¡rnÃ­ operÃ¡tor, je jedinÃ½ zpÅ¯sob,
jak nastavit nÄ›jakou hodnotu s dlouhodobou platnostÃ­.

.TernÃ¡rnÃ­ operÃ¡tor
[source,scad]
----
num = 42;

// var =   test ? TrueValue : FalseValue;

sign = num > 0 ? 1 : (num < 0 ? -1 : 0); // <1>
echo(sign); // ECHO: 1
----
<1> Zde noÅ™Ã­me operÃ¡tory do sebe

== Funkce

PodobnÄ› jako ternÃ¡rnÃ­ operÃ¡tor se zapisujÃ­ funkce. Funkce nevytvÃ¡Å™Ã­ ÄÃ¡sti CSG
stromu, pouze poÄÃ­tajÃ­ nÄ›jakou hodnotu ze svÃ©ho vstupu.
Jsou to jednovÃ½razovÃ© zkratky.

[source,scad]
function name ( parameters ) = expression;

Funkcemi se v tomto kurzu moc nezabÃ½vÃ¡me,
ale zvÃ­davÃ­ studenti je mohou samozÅ™ejmÄ› pouÅ¾Ã­vat.
https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#Functions[VÃ­ce o funkcÃ­ch v manuÃ¡lu].

== Moduly

Ekvivalentem k funkci pro CSG strom je *modul*.
Modul se vÃ­ce podobÃ¡ funkcÃ­m, jak je znÃ¡me z programovacÃ­ch jazykÅ¯,
s tÃ­m rozdÃ­lem, Å¾e nevracÃ­ Å¾Ã¡dnou hodnotu, ale uzel (Äi hranu) CSG stromu.

Laicky Å™eÄeno: model nÄ›co â€nakreslÃ­â€œ tam, kde se pouÅ¾ije.

StejnÄ› jako funkce, pÅ™ijÃ­mÃ¡ model parametry,
kterÃ© mohou nabÃ½vat vÃ½chozÃ­ch hodnot.
NavÃ­c mÅ¯Å¾e pÅ™ijÃ­mat (zpracovÃ¡vat) `children()`.

Moduly (a funkce) mohou existovat v samostatnÃ½ch souborech (knihovnÃ¡ch),
ve vlastnÃ­m souboru s modelem mÅ¯Å¾ete pouÅ¾Ã­t `use` nebo
`include`:

`use <lib.scad>;`::
  dÃ¡ k dispozici moduly a funkce ze souboru `lib.scad`

`include <lib.scad>;`::
  na mÃ­sto vloÅ¾Ã­ celÃ½ soubor `lib.scad` (pÅ™Ã­padnÃ© objekty se rovnou vykreslÃ­)

.PÅ™Ã­klad vlastnÃ­ho modulu (vÃ¡lec s kulatÃ½mi konci)
[source,scad]
----
module rounded_cylinder(h=20, r=5, center=false) {
  baseh = h-2*r;
  translate([0, 0, center ? -baseh/2 : r]) {
    cylinder(h=baseh, r=r);
    sphere(r);
    translate([0, 0, baseh]) sphere(r);
  }
}

// pro zobrazenÃ­ musÃ­te modul zavolat
rounded_cylinder(center=true);
----

.VÃ¡lec s kulatÃ½mi konci
image::ex7.png[]

=== children()

KromÄ› modulÅ¯, kterÃ© vytvÃ¡Å™ejÃ­ tvary jen na zÃ¡kladÄ› vstupnÃ­ch parametrÅ¯
(argumentÅ¯), jdou vytvÃ¡Å™et i moduly, kterÃ© pÅ™ijÃ­majÃ­ `children()`.

PouÅ¾Ã­vÃ¡ se to na modifikovÃ¡nÃ­ nebo zakomponovÃ¡nÃ­ libovolnÃ©ho objektu.

`children()`::
  reprezentuje vÅ¡echny pÅ™edanÃ© objekty

`children(n)`::
  reprezentuje _n_-tÃ½ pÅ™edanÃ½ objekt

`children([n1, ..., nx])`::
  reprezentuje _n_-prvnÃ­ aÅ¾ _n_-_x_-tÃ½ pÅ™edanÃ½ objekt

`$children`::
  magickÃ¡ (s dolarem) konstanta s poÄtem pÅ™edanÃ½ch objektÅ¯

`children([1 : 2 : $children])`::
  kaÅ¾dÃ½ druhÃ½ pÅ™edanÃ½ objekt

.PÅ™Ã­klad modulu, kterÃ½ provede s `children()` nÄ›jakou operaci
[source,scad]
----
module elongate() {
  scale([10 , 1, 1])
    children();
}

elongate() {
  sphere(30);
  cube(45, center=true);
  cylinder(r=10, h=50);
}
----

.PÅ™Ã­klad pouÅ¾itÃ­ modulu `elongate()`
image::ex8.png[]

== Debugging

Pro debugging modelÅ¯ je dobbrÃ© nauÄit si nÄ›kolik modifikÃ¡torÅ¯:

`%`::
  kbd:[F5] vykreslÃ­ uzel poloprÅ¯hlednÄ›, kbd:[F6] vÅ¯bec

`#`::
  kbd:[F5] vykreslÃ­ uzel poloprÅ¯hlednÄ› a ÄervenÄ›, kbd:[F6] normÃ¡lnÄ›

`!`::
  kbd:[F5] i kbd:[F6] zobrazÃ­ pouze tento uzel

`*`::
  kbd:[F5] i kbd:[F6] tento uzel bude ignorovat

.ModifikÃ¡tor `#`
[source,scad]
----
difference() {
  sphere(45);
  #cube(65, center=true);
}
----

.ModifikÃ¡tor `#`
image::ex9.png[]

== PomocnÃ­Äci

WARNING: Zde zhruba konÄÃ­ obsah druhÃ©ho cviÄenÃ­ a pokraÄuje obsah tÅ™etÃ­ho.

SpeciÃ¡lnÃ­mi operacemi v OpenSCADu jsou  `minkowski()` a `hull()`.
PomocÃ­ nich mÅ¯Å¾ete vyvÃ¡Å™et sloÅ¾itÃ© tvary,
kterÃ© by se jinak vytvÃ¡Å™ely velice obtÃ­Å¾nÄ›.

=== MinkowskÃ©ho suma

https://en.wikipedia.org/wiki/Minkowski_addition[MinkowskÃ©ho suma] je mnoÅ¾inovÃ¡ operace,
kdy vÅ¡echny body z jednÃ© mnoÅ¾iny seÄtete se vÅ¡emi body z druhÃ© mnoÅ¾iny.
NejlÃ©pe to vystihuje nÃ¡sledujÃ­cÃ­ obrÃ¡zek:

.MinkowskÃ©ho suma Â©  https://en.wikipedia.org/wiki/File:Ğ¡ÑƒĞ¼Ğ¼Ğ°_ĞœĞ¸Ğ½ĞºĞ¾Ğ²ÑĞºĞ¾Ğ³Ğ¾.svg[Tosha] (Public Domain)
image::minkowski.svg[width=500]

MÅ¯Å¾ete si to pÅ™edstavit tak,
Å¾e jeden z objektÅ¯ uchopÃ­te za poÄÃ¡tek souÅ™adnÃ½
a objÃ­Å¾dÃ­te s nÃ­m po povrchu druhÃ©ho objektu, zanechÃ¡vajÃ­c za sebou stopu.
JednÃ¡ se o operaci komutativnÃ­ a asociativnÃ­, je tedy jedno,
kterÃ½m objektem jezdÃ­te po kterÃ©m.
V praxi se tato operace pouÅ¾Ã­vÃ¡ vÄ›tÅ¡inou s koulÃ­ pro zaoblenÃ­,
ale pozor, zaoblenÃ½ objekt se zvÄ›tÅ¡Ã­.

.Operace `minkowski()`
[source,scad]
minkowski() {
  cube(300);
  sphere(30);
}

.Vlevo operandy, vpravo vÃ½sledek operace `minkowski()`
image::ex5.png[width=500]

WARNING: VypoÄtenÃ­ minkowskÃ©ho sumy mÅ¯Å¾e trvat **velmi dlouho**.

=== KonvexnÃ­ obal

KonvexnÃ­ obal (__convex hull__) objektÅ¯ je takovÃ½ nejmenÅ¡Ã­ konvexnÃ­ objekt,
kterÃ½ pojme vÅ¡echny objekty v nÄ›m.
OpÄ›t se jednÃ¡ o komutativnÃ­ a asociativnÃ­ https://en.wikipedia.org/wiki/Convex_hull[mnoÅ¾inovou operaci].

.Operace `hull()`
[source,scad]
hull() {
  cube(100);
  sphere(30);
}

.Vlevo operandy, vpravo vÃ½sledek operace `hull()`
image::ex5a.png[width=500]

WARNING: VypoÄtenÃ­ konvexnÃ­ho obalu mÅ¯Å¾e trvat celkem dlouho.

== DvourozmÄ›rnÃ½ subsystÃ©m

ZatÃ­m jsme vytvÃ¡Å™eli jen trojrozmÄ›rnÃ© objekty.
V OpenSCADu se dÃ¡ ale vyuÅ¾Ã­t dvourozmÄ›rnÃ½ subsystÃ©m,
ve kterÃ©m se pracuje jen na jednÃ© rovinÄ›.

V 2D subsystÃ©mu je moÅ¾nÃ© vyvÃ¡Å™et 2D primitiva:
`circle()`, `square()` a `polygon()`.

PomocÃ­ `linear_extrude()` nebo `rotate_extrude()` jde z 2D objektu vytvoÅ™it 3D objekt.
Naopak `projection()` slouÅ¾Ã­ k projekci 3D objektÅ¯ do 2D.

NOTE: 2D objekty v nÃ¡hledu vypadajÃ­ jako malÃ© ÃºzkÃ© 3D objekty,
ale nejdou tak vyrenderovat. Nelze ve stromu spojovat 2D a 3D objekty.
(`WARNING: Mixing 2D and 3D objects is not supported.`
`WARNING: Ignoring 3D child object for 2D operation.`)

KdyÅ¾ pracujete ve 2D subsystÃ©mu, lze pouÅ¾Ã­t vÅ¡e, co jiÅ¾ znÃ¡te,
jen API nÄ›kterÃ½ch operacÃ­ se nÃ¡leÅ¾itÄ› zmÄ›nÃ­
(napÅ™. `translate()` bere vektor 2 hodnot, `rotate()` bere jen jeden Ãºhelâ€¦).

.DvourozmÄ›rnÃ½ subsystÃ©m
[source,scad]
hull() {
  rotate(45) square([25, 15]);
  translate([12, 7]) circle(7);
}

.DvourozmÄ›rnÃ½ subsystÃ©m
image::ex11a.png[]

Operace `hull()` a `minkowski()` jsou ve 2D subsystÃ©mu relativnÄ› rychlÃ©.
Pokud to jde, je tedy lepÅ¡Ã­ provÃ¡dÄ›t je v nÄ›m.

=== 2D primitiva

`square()`::
  alternativa ke `cube()`

`circle()`::
  alternativa ke `sphere()`

`polygon()`::
  alternativa k `polyhedron()`

=== offset()

K zaoblenÃ­ dvourozmÄ›rnÃ½ch tvarÅ¯ lze pouÅ¾Ã­t `offset()`.
Ten mÃ¡ nÄ›kolik zpÅ¯sobÅ¯ pouÅ¾itÃ­:

.PouÅ¾itÃ­ kladnÃ©ho offsetu v zÃ¡vislosti na pouÅ¾itÃ½ch argumentech a jejich hodnotÃ¡ch Â© https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#offset[Torsten Paul] (CC BY-SA)
image::offset_out.svg[width=500]

.PouÅ¾itÃ­ zÃ¡pornÃ©ho offsetu v zÃ¡vislosti na pouÅ¾itÃ½ch argumentech a jejich hodnotÃ¡ch Â© https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#offset[Torsten Paul] (CC BY-SA)
image::offset_in.svg[width=500]


=== linear_extrude()

Operace `linear_extrude()` vytÃ¡hne 2D tvar do prostoru a vytvoÅ™Ã­ tedy 3D tvar.
Lze nastavit nÄ›kolik parametrÅ¯:

`height`::
  vÃ½Å¡ka vytaÅ¾enÃ­

`center`::
  `false` vytahuje jen nahoru, `true` na oba smÄ›ry (kaÅ¾dÃ½ o polovinu vÃ½Å¡ky)

`twist`::
  o kolik stupÅˆÅ¯ se 2D tvar pÅ™i vytaÅ¾enÃ­ otoÄÃ­

`slices`::
  poÄet krokÅ¯ u `twist`

`scale`::
  kolikrÃ¡t se 2D tvar pÅ™i vytaÅ¾enÃ­ zvÄ›tÅ¡Ã­

`convexity`::
  hodnota ovlivÅˆujÃ­cÃ­ nÃ¡hled; kuchaÅ™ radÃ­: â€nevÃ­Å¡-li, dej tam 10â€œ

.PouÅ¾itÃ­ `linear_extrude()`
[source,scad]
linear_extrude(height=20, twist=180, slices=100, center=true) {
  square(5);
  square(5, center=true);
}

.PouÅ¾itÃ­ `linear_extrude()`
image::ex11.png[]

=== rotate_extrude()

DalÅ¡Ã­ moÅ¾nostÃ­, jak pÅ™evÃ©st 2D tvar na 3D tvar, je rotovat ho.
K tomu slouÅ¾Ã­ `rotate_extrude()`, kterÃ© rotuje 2D tvar do prostoru.

Rotace probÃ­hÃ¡ kolem osy Y, ale objekt se â€vzpÅ™Ã­mÃ­â€œ kolem osy Z
(dodnes nevÃ­me proÄ).

NOTE: PouÅ¾itÃ½ 2D tvar nesmÃ­ zasahovat zÃ¡roveÅˆ do kladnÃ© a zÃ¡pornÃ© ÄÃ¡sti osy Y.
PÅ™esnÄ›ji Å™eÄeno, buÄto musÃ­ vÅ¡echny body mÃ­t X souÅ™adnici nezÃ¡pornou,
nebo vÅ¡echny nekladnou.

.PouÅ¾itÃ­ `rotate_extrude()`
[source,scad]
rotate_extrude()
  polygon(points=[[0,0],[20,10],[10,20],[10,30],[30,40],[0,50]]);

.PouÅ¾itÃ­ `rotate_extrude()`
image::ex10.png[]

=== projection()

Projekce (`projection()`) promÃ­tne 3D objekt na rovinu XY.
Parametr `cut` umoÅ¾nÃ­ pouÅ¾Ã­t jen prÅ¯nik s rovinou XY.
VÃ½sledkem projekce je vÅ¾dy 2D tvar;
ten pak mÅ¯Å¾ete vyuÅ¾Ã­t opÄ›t k vytvoÅ™enÃ­ 3D tvaru.

.Parabola pomocÃ­ `projection()`
[source,scad]
projection(cut=true)
  translate([0, 0, -15])
    rotate([45, 0, 0])
      cylinder(r1=0, r2=500, h=500);

.Parabola pomocÃ­ `projection()`
image::ex13.png[]

== import()

Pro pouÅ¾itÃ­ jiÅ¾ existujÃ­cÃ­ch 2D nebo 3D tvarÅ¯ mÅ¯Å¾ete pouÅ¾Ã­t `import()`,
pomocÃ­ nÄ›hoÅ¾ lze do CSG stromu vloÅ¾it STL a DXF soubory.
Argumentem je cesta k souboru (relativnÃ­ Äi absolutnÃ­).

PÅ™i importovÃ¡nÃ­ 2D tvarÅ¯ (DXF) si dejte pÅ™edevÅ¡Ã­m pozor na vÃ½slednou velikost,
je vhodnÃ© pouÅ¾Ã­t `resize()`.

.PouÅ¾itÃ­ 2D tvaru ze souboru
[source,scad]
rotate_extrude() 
  resize([20, 0], auto=[false, true])
    import("bottle.dxf");

.PouÅ¾itÃ­ 2D tvaru ze souboru
image::ex12.png[]

ImportovanÃ© soubory lze vyuÅ¾Ã­t k jakÃ½mkoliv dalÅ¡Ã­m operacÃ­m.
CizÃ­ STL soubory se ne vÅ¾dy povedou vyrenderovat,
je tÅ™eba je nejprve opravit,
k tomu se dostaneme ve cviÄenÃ­ o xref:mesh#[opravÄ› meshe].

.PouÅ¾itÃ­ 3D tvaru ze souboru
[source,scad]
difference() {
  import("kangaroo.stl"); // http://www.thingiverse.com/thing:33273 CC BY-NC-SA
  translate([0, -10, 80])
    cube(30, center=true);
}

.PouÅ¾itÃ­ 3D tvaru ze souboru
image::ex14.png[]

== surface()

AlternativnÃ­m zpÅ¯sobem vyuÅ¾itÃ© externÃ­ch souborÅ¯ je `surface()`,
kterÃ½ slouÅ¾Ã­ k pÅ™evodu obrÃ¡zkÅ¯ do vÃ½Å¡kovÃ© mapy.

.`surface(file="smiley.png", center=true);` Â© https://commons.wikimedia.org/wiki/File:OpenSCAD_surface_example.png[Torsten Paul] (CC BY-SA)
image::surface.png[]

== RozliÅ¡enÃ­

JistÄ› jste si vÅ¡imli, Å¾e kulatÃ© vÄ›ci jsou v OpenSCADu hranatÃ©.
ÄŒÃ­m menÅ¡Ã­ jsou, tÃ­m je to vÃ­ce poznat.

.Koule velikosti 1
image::ex16a.png[]

PomocÃ­ speciÃ¡lnÃ­ch promÄ›nnÃ½ch `$fn`, `$fa` a `$fs` lze rozliÅ¡enÃ­ mÄ›nit,
viz http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/The_OpenSCAD_Language#.24fa.2C_.24fs_and_.24fn[manuÃ¡l].
V praxi se nejÄastÄ›ji nastavuje promÄ›nnÃ¡ `$fn`,
kterÃ¡ nastavÃ­ absolutnÃ­ poÄet hran na kruh (minimÃ¡lnÄ› 3).
Tvary jsou vytvoÅ™enÃ© tak, Å¾e zadanÃ¡ velikost je velikost opsanÃ© kruÅ¾nice.
PromÄ›nou `$fn` lze vyuÅ¾Ã­t napÅ™Ã­klad k vytvoÅ™enÃ­ __n__-ÃºhelnÃ­ku.

Tyto speciÃ¡lnÃ­ promÄ›nnÃ© se mohou nastavit globÃ¡lnÄ›, ve scopu nebo argumentem
libovolnÃ© operaci, primitivu Äi modulu.
PÅ™i vytvÃ¡Å™enÃ­ modulÅ¯ nenÃ­ tÅ™eba tyto promÄ›nnÃ© uvÃ¡dÄ›t v pÅ™edpisu.

.`for (fn=[1:10]) translate([fn*2.1,0,0]) circle($fn=fn);`
image::fn.png[]

== Simple â€“ 2-Manifold

Pro sprÃ¡vnÃ½ export STL souboru je potÅ™eba,
aby byl model Simple â€“ https://en.wikipedia.org/wiki/2-manifold[2-Manifold].
To mj. znamenÃ¡, Å¾e stÄ›ny modelu se nemohou vÅ¡elijak protÃ­nat.
Skoro vÅ¡echny moÅ¾nÃ© problÃ©my Å™eÅ¡Ã­ vÃ½slednÃ½ implicitnÃ­ `union()`.
NÄ›jakÃ© problÃ©my ale pÅ™ece jen mÅ¯Å¾ou vzniknout,
napÅ™Ã­klad pÅ™i nesprÃ¡vnÃ©m pouÅ¾itÃ­ polyhedronu.

JednÃ­m z problÃ©mÅ¯, kterÃ½ mÅ¯Å¾e nastat jednoduÅ¡e,
je spoleÄnÃ¡ hrana dvou objektÅ¯.
Pokud si pÅ™edstavÃ­te dvÄ› kostky (napÅ™. z obrÃ¡zku nÃ­Å¾e),
v reÃ¡lnÃ©m svÄ›tÄ› nemohou mÃ­t spoleÄnou hranu.
BuÄto jde â€projÃ­tâ€œ z jednÃ© kostky do druhÃ©, nebo â€jde projÃ­tâ€œ mezi nimi;
jinÃ½mi slovy buÄto to jsou dvÄ› kostky nebo jedna dvoukostka.

.DvÄ› kostky nemohou sdÃ­let hranu
image::ex15.png[]

.Takhle to nejde
[source,scad]
cube(20);
translate([20, 20, 0]) cube(20);

.Jde to takhle
[source,scad]
e=0.0001;
cube(20);
translate([20-e, 20-e, 0]) cube(20);

.Nebo takhle
[source,scad]
e=0.0001;
cube(20);
translate([20+e, 20+e, 0]) cube(20);

== Knihovna MCAD

PomocÃ­ modulÅ¯ lze pro OpenSCAD vytvÃ¡Å™et rÅ¯znÃ© knihovny.
NÄ›kterÃ© jiÅ¾ existujÃ­, jednou z nich je knihovna
https://github.com/openscad/MCAD#openscad-mcad-library[MCAD],
kterÃ¡ bÃ½vÃ¡ Äasto distribuovanÃ¡ spoleÄnÄ› s OpenSCADem.

Knihovna MCAD obsahuje spoustu elementÃ¡rnÃ­ch i pokroÄilÃ½ch vÄ›cÃ­:

* novÃ© tvary, 
* vhodnÃ© vÄ›ci pro RepRap:
** motorky,
** Å™emeniÄkyâ€¦

Pro pouÅ¾itÃ­ knihovny MCAD je potÅ™eba pouÅ¾Ã­t `include`, ne `use`.

.PouÅ¾itÃ­ knihovny MCAD
[source,scad]
include <MCAD/stepper.scad>
motor(Nema17);

.Je libo motor NEMA 17?
image::ex16.png[]

== PokroÄilÃ¡ prÃ¡ce s promÄ›nnÃ½mi

* xref:openscad/openscad-vars#[pÅ™Ã­klady chovÃ¡nÃ­]

== PÅ™Ã­klady ze cviÄenÃ­

* xref:openscad/openscad-molecule#[molekula]
